# utils/database_manager.py - ÌÜµÌï© Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Í¥ÄÎ¶¨Ïûê
import sqlite3
import logging
import threading
from contextlib import contextmanager
from typing import Optional, Dict, List, Any
from datetime import datetime
import json
import os
from pathlib import Path

# Î°úÍπÖ ÏÑ§Ï†ï
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class DatabaseManager:
    """üóÑÔ∏è ÌÜµÌï© Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Í¥ÄÎ¶¨ ÌÅ¥ÎûòÏä§"""
    
    _instance = None
    _lock = threading.Lock()
    
    def __new__(cls, db_path: str = "instagram_marketing.db"):
        """Ïã±Í∏ÄÌÜ§ Ìå®ÌÑ¥ Íµ¨ÌòÑ"""
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
                    cls._instance._initialized = False
        return cls._instance
    
    def __init__(self, db_path: str = "instagram_marketing.db"):
        """Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Í¥ÄÎ¶¨Ïûê Ï¥àÍ∏∞Ìôî"""
        if self._initialized:
            return
            
        self.db_path = db_path
        self.connection_pool = {}
        self._local = threading.local()
        self._ensure_database_directory()
        self._initialized = True
        
        # Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï¥àÍ∏∞Ìôî
        self.initialize_database()
        logger.info(f"‚úÖ DatabaseManager Ï¥àÍ∏∞Ìôî ÏôÑÎ£å: {db_path}")
    
    def _ensure_database_directory(self):
        """Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÎîîÎ†âÌÜ†Î¶¨ ÌôïÏù∏/ÏÉùÏÑ±"""
        db_dir = Path(self.db_path).parent
        if not db_dir.exists():
            db_dir.mkdir(parents=True, exist_ok=True)
            logger.info(f"üìÅ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ±: {db_dir}")
    
    @contextmanager
    def get_connection(self, timeout: int = 30):
        """
        üîó ÏïàÏ†ÑÌïú Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ Ïª®ÌÖçÏä§Ìä∏ Îß§ÎãàÏ†Ä
        
        Usage:
            with db_manager.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("SELECT * FROM users")
        """
        conn = None
        try:
            conn = sqlite3.connect(
                self.db_path, 
                timeout=timeout,
                check_same_thread=False
            )
            # Row factory ÏÑ§Ï†ïÏúºÎ°ú ÎîïÏÖîÎÑàÎ¶¨ ÌòïÌÉú Í≤∞Í≥º Î∞òÌôò
            conn.row_factory = sqlite3.Row
            
            # Ïô∏Îûò ÌÇ§ Ï†úÏïΩÏ°∞Í±¥ ÌôúÏÑ±Ìôî
            conn.execute("PRAGMA foreign_keys = ON")
            
            # WAL Î™®Îìú ÏÑ§Ï†ï (ÎèôÏãúÏÑ± Ìñ•ÏÉÅ)
            conn.execute("PRAGMA journal_mode = WAL")
            
            yield conn
            
        except sqlite3.Error as e:
            if conn:
                conn.rollback()
            logger.error(f"‚ùå Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïò§Î•ò: {e}")
            raise
        except Exception as e:
            if conn:
                conn.rollback()
            logger.error(f"‚ùå ÏòàÏÉÅÏπò Î™ªÌïú Ïò§Î•ò: {e}")
            raise
        finally:
            if conn:
                conn.close()
    
    @contextmanager
    def get_transaction(self):
        """
        üîÑ Ìä∏ÎûúÏû≠ÏÖò Ïª®ÌÖçÏä§Ìä∏ Îß§ÎãàÏ†Ä
        
        Usage:
            with db_manager.get_transaction() as cursor:
                cursor.execute("INSERT INTO users ...")
                cursor.execute("INSERT INTO businesses ...")
                # ÏûêÎèôÏúºÎ°ú commit ÎòêÎäî rollback
        """
        with self.get_connection() as conn:
            cursor = conn.cursor()
            try:
                yield cursor
                conn.commit()
                logger.debug("‚úÖ Ìä∏ÎûúÏû≠ÏÖò Ïª§Î∞ã ÏôÑÎ£å")
            except Exception as e:
                conn.rollback()
                logger.error(f"üîÑ Ìä∏ÎûúÏû≠ÏÖò Î°§Î∞±: {e}")
                raise
    
    def execute_query(self, query: str, params: tuple = (), fetch_one: bool = False, fetch_all: bool = True) -> Optional[Any]:
        """
        üìù ÏøºÎ¶¨ Ïã§Ìñâ (SELECTÏö©)
        
        Args:
            query: SQL ÏøºÎ¶¨
            params: ÌååÎùºÎØ∏ÌÑ∞ ÌäúÌîå
            fetch_one: Îã®Ïùº Í≤∞Í≥º Î∞òÌôò
            fetch_all: Î™®Îì† Í≤∞Í≥º Î∞òÌôò
        """
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute(query, params)
                
                if fetch_one:
                    result = cursor.fetchone()
                    return dict(result) if result else None
                elif fetch_all:
                    results = cursor.fetchall()
                    return [dict(row) for row in results]
                else:
                    return None
                    
        except sqlite3.Error as e:
            logger.error(f"‚ùå ÏøºÎ¶¨ Ïã§Ìñâ Ïò§Î•ò: {e}")
            logger.error(f"   ÏøºÎ¶¨: {query}")
            logger.error(f"   ÌååÎùºÎØ∏ÌÑ∞: {params}")
            raise
    
    def execute_command(self, query: str, params: tuple = ()) -> int:
        """
        ‚ö° Î™ÖÎ†π Ïã§Ìñâ (INSERT, UPDATE, DELETEÏö©)
        
        Returns:
            ÏòÅÌñ•Î∞õÏùÄ Ìñâ Ïàò ÎòêÎäî ÎßàÏßÄÎßâ ÏÇΩÏûÖ ID
        """
        try:
            with self.get_transaction() as cursor:
                cursor.execute(query, params)
                
                if query.strip().upper().startswith('INSERT'):
                    return cursor.lastrowid
                else:
                    return cursor.rowcount
                    
        except sqlite3.Error as e:
            logger.error(f"‚ùå Î™ÖÎ†π Ïã§Ìñâ Ïò§Î•ò: {e}")
            logger.error(f"   ÏøºÎ¶¨: {query}")
            logger.error(f"   ÌååÎùºÎØ∏ÌÑ∞: {params}")
            raise
    
    def execute_many(self, query: str, params_list: List[tuple]) -> int:
        """
        üì¶ Î∞∞Ïπò Ïã§Ìñâ (Ïó¨Îü¨ Ìñâ Ï≤òÎ¶¨)
        
        Returns:
            Ï≤òÎ¶¨Îêú Ìñâ Ïàò
        """
        try:
            with self.get_transaction() as cursor:
                cursor.executemany(query, params_list)
                return cursor.rowcount
                
        except sqlite3.Error as e:
            logger.error(f"‚ùå Î∞∞Ïπò Ïã§Ìñâ Ïò§Î•ò: {e}")
            logger.error(f"   ÏøºÎ¶¨: {query}")
            logger.error(f"   Î∞∞Ïπò ÌÅ¨Í∏∞: {len(params_list)}")
            raise
    
    def initialize_database(self):
        """üèóÔ∏è Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÌÖåÏù¥Î∏î Ï¥àÍ∏∞Ìôî"""
        try:
            with self.get_transaction() as cursor:
                # ÏÇ¨Ïö©Ïûê ÌÖåÏù¥Î∏î
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS users (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        email TEXT UNIQUE NOT NULL,
                        password_hash TEXT NOT NULL,
                        created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
                        updated_at TEXT,
                        is_active BOOLEAN DEFAULT TRUE,
                        last_login TEXT,
                        CONSTRAINT email_format CHECK (email LIKE '%@%')
                    )
                """)
                
                # ÎπÑÏ¶àÎãàÏä§ ÌÖåÏù¥Î∏î
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS businesses (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        user_id INTEGER NOT NULL,
                        business_name TEXT NOT NULL,
                        industry TEXT NOT NULL,
                        target_audience TEXT,
                        brand_voice TEXT,
                        phone TEXT,
                        website TEXT,
                        instagram_username TEXT,
                        created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
                        updated_at TEXT,
                        FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
                    )
                """)
                
                # ÏΩòÌÖêÏ∏† ÌÖåÏù¥Î∏î
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS content (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        business_id INTEGER NOT NULL,
                        title TEXT,
                        caption TEXT NOT NULL,
                        hashtags TEXT, -- JSON ÌòïÌÉúÎ°ú Ï†ÄÏû•
                        image_url TEXT,
                        content_type TEXT DEFAULT 'post',
                        platform TEXT DEFAULT 'instagram',
                        status TEXT DEFAULT 'draft',
                        created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
                        updated_at TEXT,
                        published_at TEXT,
                        likes_count INTEGER DEFAULT 0,
                        comments_count INTEGER DEFAULT 0,
                        shares_count INTEGER DEFAULT 0,
                        engagement_rate REAL DEFAULT 0.0,
                        FOREIGN KEY (business_id) REFERENCES businesses (id) ON DELETE CASCADE,
                        CONSTRAINT status_check CHECK (status IN ('draft', 'scheduled', 'published', 'failed'))
                    )
                """)
                
                # ÏΩòÌÖêÏ∏† Ïä§ÏºÄÏ§Ñ ÌÖåÏù¥Î∏î
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS content_schedule (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        business_id INTEGER NOT NULL,
                        content_id INTEGER NOT NULL,
                        scheduled_datetime TEXT NOT NULL,
                        status TEXT DEFAULT 'pending',
                        post_id TEXT,
                        error_message TEXT,
                        retry_count INTEGER DEFAULT 0,
                        created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
                        completed_at TEXT,
                        FOREIGN KEY (business_id) REFERENCES businesses (id) ON DELETE CASCADE,
                        FOREIGN KEY (content_id) REFERENCES content (id) ON DELETE CASCADE,
                        CONSTRAINT schedule_status_check CHECK (status IN ('pending', 'completed', 'failed', 'cancelled'))
                    )
                """)
                
                # Î∂ÑÏÑù Îç∞Ïù¥ÌÑ∞ ÌÖåÏù¥Î∏î
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS analytics (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        business_id INTEGER NOT NULL,
                        date TEXT NOT NULL,
                        followers_count INTEGER DEFAULT 0,
                        following_count INTEGER DEFAULT 0,
                        posts_count INTEGER DEFAULT 0,
                        engagement_rate REAL DEFAULT 0.0,
                        reach INTEGER DEFAULT 0,
                        impressions INTEGER DEFAULT 0,
                        likes INTEGER DEFAULT 0,
                        comments INTEGER DEFAULT 0,
                        shares INTEGER DEFAULT 0,
                        saves INTEGER DEFAULT 0,
                        created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (business_id) REFERENCES businesses (id) ON DELETE CASCADE,
                        UNIQUE(business_id, date)
                    )
                """)
                
                # ÎπÑÏ¶àÎãàÏä§ ÏÑ§Ï†ï ÌÖåÏù¥Î∏î
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS business_settings (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        business_id INTEGER NOT NULL,
                        auto_post_enabled BOOLEAN DEFAULT TRUE,
                        post_frequency INTEGER DEFAULT 1,
                        preferred_times TEXT DEFAULT '["09:00", "12:00", "18:00"]', -- JSON
                        content_themes TEXT DEFAULT '["product", "lifestyle", "behind_scenes"]', -- JSON
                        created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
                        updated_at TEXT,
                        FOREIGN KEY (business_id) REFERENCES businesses (id) ON DELETE CASCADE,
                        UNIQUE(business_id)
                    )
                """)
                
                # ÏÑ±Í≥º Ï∂îÏ†Å ÌÖåÏù¥Î∏î
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS performance_tracking (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        business_id INTEGER NOT NULL,
                        post_id TEXT,
                        content_type TEXT,
                        posted_at TEXT,
                        likes_count INTEGER DEFAULT 0,
                        comments_count INTEGER DEFAULT 0,
                        engagement_rate REAL DEFAULT 0.0,
                        reach INTEGER DEFAULT 0,
                        impressions INTEGER DEFAULT 0,
                        last_updated TEXT DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (business_id) REFERENCES businesses (id) ON DELETE CASCADE
                    )
                """)
                
                # Ïù∏Îç±Ïä§ ÏÉùÏÑ±
                self._create_indexes(cursor)
                
                logger.info("‚úÖ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÌÖåÏù¥Î∏î Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
                
        except sqlite3.Error as e:
            logger.error(f"‚ùå Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï¥àÍ∏∞Ìôî Ïò§Î•ò: {e}")
            raise
    
    def _create_indexes(self, cursor):
        """üìä Ïù∏Îç±Ïä§ ÏÉùÏÑ±ÏúºÎ°ú ÏÑ±Îä• ÏµúÏ†ÅÌôî"""
        indexes = [
            "CREATE INDEX IF NOT EXISTS idx_users_email ON users(email)",
            "CREATE INDEX IF NOT EXISTS idx_users_active ON users(is_active)",
            "CREATE INDEX IF NOT EXISTS idx_businesses_user_id ON businesses(user_id)",
            "CREATE INDEX IF NOT EXISTS idx_content_business_id ON content(business_id)",
            "CREATE INDEX IF NOT EXISTS idx_content_status ON content(status)",
            "CREATE INDEX IF NOT EXISTS idx_content_created_at ON content(created_at)",
            "CREATE INDEX IF NOT EXISTS idx_schedule_datetime ON content_schedule(scheduled_datetime)",
            "CREATE INDEX IF NOT EXISTS idx_schedule_status ON content_schedule(status)",
            "CREATE INDEX IF NOT EXISTS idx_analytics_business_date ON analytics(business_id, date)",
            "CREATE INDEX IF NOT EXISTS idx_performance_business ON performance_tracking(business_id)"
        ]
        
        for index_sql in indexes:
            try:
                cursor.execute(index_sql)
            except sqlite3.Error as e:
                logger.warning(f"‚ö†Ô∏è Ïù∏Îç±Ïä§ ÏÉùÏÑ± Ïã§Ìå®: {e}")
    
    def backup_database(self, backup_path: Optional[str] = None) -> str:
        """üíæ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Î∞±ÏóÖ"""
        if not backup_path:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_path = f"{self.db_path}.backup_{timestamp}"
        
        try:
            with self.get_connection() as source:
                with sqlite3.connect(backup_path) as backup:
                    source.backup(backup)
            
            logger.info(f"‚úÖ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Î∞±ÏóÖ ÏôÑÎ£å: {backup_path}")
            return backup_path
            
        except Exception as e:
            logger.error(f"‚ùå Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Î∞±ÏóÖ Ïã§Ìå®: {e}")
            raise
    
    def get_database_stats(self) -> Dict[str, Any]:
        """üìä Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÌÜµÍ≥Ñ Ï†ïÎ≥¥"""
        stats = {}
        
        try:
            tables = [
                'users', 'businesses', 'content', 'content_schedule',
                'analytics', 'business_settings', 'performance_tracking'
            ]
            
            for table in tables:
                count = self.execute_query(
                    f"SELECT COUNT(*) as count FROM {table}",
                    fetch_one=True
                )
                stats[f"{table}_count"] = count['count'] if count else 0
            
            # Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÌÅ¨Í∏∞
            db_size = os.path.getsize(self.db_path) if os.path.exists(self.db_path) else 0
            stats['database_size_mb'] = round(db_size / (1024 * 1024), 2)
            
            # ÏµúÍ∑º ÌôúÎèô
            recent_content = self.execute_query(
                "SELECT created_at FROM content ORDER BY created_at DESC LIMIT 1",
                fetch_one=True
            )
            stats['last_content_created'] = recent_content['created_at'] if recent_content else None
            
            return stats
            
        except Exception as e:
            logger.error(f"‚ùå Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÌÜµÍ≥Ñ Ï°∞Ìöå Ïò§Î•ò: {e}")
            return {}
    
    def cleanup_old_data(self, days: int = 30):
        """üßπ Ïò§ÎûòÎêú Îç∞Ïù¥ÌÑ∞ Ï†ïÎ¶¨"""
        try:
            cutoff_date = datetime.now().strftime("%Y-%m-%d")
            
            with self.get_transaction() as cursor:
                # ÏôÑÎ£åÎêú Ïä§ÏºÄÏ§Ñ Îç∞Ïù¥ÌÑ∞ Ï†ïÎ¶¨
                cursor.execute("""
                    DELETE FROM content_schedule 
                    WHERE status = 'completed' 
                    AND date(completed_at) < date('now', '-{} days')
                """.format(days))
                
                deleted_schedules = cursor.rowcount
                
                # Ïã§Ìå®Ìïú Ïä§ÏºÄÏ§Ñ Îç∞Ïù¥ÌÑ∞ Ï†ïÎ¶¨ (Ïû¨ÏãúÎèÑ ÌöüÏàò ÎßéÏùÄ Í≤É)
                cursor.execute("""
                    DELETE FROM content_schedule 
                    WHERE status = 'failed' 
                    AND retry_count > 3
                    AND date(created_at) < date('now', '-7 days')
                """)
                
                deleted_failed = cursor.rowcount
                
                logger.info(f"üßπ Îç∞Ïù¥ÌÑ∞ Ï†ïÎ¶¨ ÏôÑÎ£å: Ïä§ÏºÄÏ§Ñ {deleted_schedules}Í∞ú, Ïã§Ìå® {deleted_failed}Í∞ú ÏÇ≠Ï†ú")
                
        except Exception as e:
            logger.error(f"‚ùå Îç∞Ïù¥ÌÑ∞ Ï†ïÎ¶¨ Ïò§Î•ò: {e}")
            raise
    
    def health_check(self) -> Dict[str, Any]:
        """üè• Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÉÅÌÉú ÌôïÏù∏"""
        try:
            start_time = datetime.now()
            
            # Ïó∞Í≤∞ ÌÖåÏä§Ìä∏
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("SELECT 1")
                result = cursor.fetchone()
            
            end_time = datetime.now()
            response_time = (end_time - start_time).total_seconds()
            
            return {
                'status': 'healthy',
                'response_time_seconds': response_time,
                'database_path': self.db_path,
                'connection_test': 'passed',
                'timestamp': datetime.now().isoformat()
            }
            
        except Exception as e:
            return {
                'status': 'unhealthy',
                'error': str(e),
                'database_path': self.db_path,
                'connection_test': 'failed',
                'timestamp': datetime.now().isoformat()
            }

# Ï†ÑÏó≠ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Îß§ÎãàÏ†Ä Ïù∏Ïä§ÌÑ¥Ïä§
db_manager = DatabaseManager()

def get_db_manager() -> DatabaseManager:
    """Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Îß§ÎãàÏ†Ä Ïù∏Ïä§ÌÑ¥Ïä§ Î∞òÌôò"""
    return db_manager